# Библиотека логирования

Библиотека для записи сообщений в журнал с разными уровнями важности, включающая консольные приложения для демонстрации и сбора статистики.

## Возможности

- **Многопоточная запись логов** с потокобезопасностью
- **Три уровня важности**: DEBUG, INFO, WARNING
- **Фильтрация сообщений** по уровню важности
- **Гибкие варианты вывода**: файл или сокет
- **Статическая и динамическая сборка** библиотеки
- **Форматированный вывод** с временными метками
- **Приложение для сбора статистики** через сокет

## Структура проекта

```
LoggingLibrary/
├── CMakeLists.txt              # Основной файл сборки
├── README.md                   # Документация
├── include/
│   └── logging/
│       └── Logger.h           # Заголовочный файл библиотеки
├── src/
│   ├── CMakeLists.txt         # Сборка библиотеки
│   └── Logger.cpp             # Реализация библиотеки
├── apps/
│   ├── CMakeLists.txt         # Сборка приложений
│   ├── test_logger/
│   │   ├── CMakeLists.txt     # Тестовое приложение
│   │   └── main.cpp
│   └── log_stats/
│       ├── CMakeLists.txt     # Приложение статистики
│       └── main.cpp
└── tests/
    ├── CMakeLists.txt         # Сборка тестов
    └── unit_tests.cpp        # Юнит тесты
```

## Сборка

### Требования

- **Компилятор**: GCC с поддержкой C++17
- **Система сборки**: CMake 3.12+
- **ОС**: Ubuntu/Debian (актуальные версии)
- **Зависимости**: pthread (включен в стандартную поставку)

### Команды сборки

```bash
# Клонирование репозитория
git clone <https://github.com/sofikuz274/Logging_library.git>
cd LoggingLibrary

# Создание директории сборки
mkdir build && cd build

# Конфигурация проекта
cmake ..

# Сборка проекта
make

# Запуск тестов
make test
# или
ctest --verbose
```

### Цели сборки

- `logging_static` - статическая библиотека
- `logging_shared` - динамическая библиотека  
- `test_logger` - тестовое приложение
- `log_stats` - приложение статистики
- `test_logger` (тесты) - юнит-тесты
- `run_tests` - запуск всех тестов
- `demo` - демонстрация возможностей

## Использование библиотеки

### Основные классы

#### `logging::Logger`

Основной класс для записи логов.

```cpp
#include "logging/Logger.h"

// Создание логгера для записи в файл
logging::Logger logger("app.log", logging::LogLevel::INFO);

// Запись сообщений
logger.info("Приложение запущено");
logger.warning("Предупреждение");
logger.debug("Отладочная информация"); // Не записывается (уровень ниже INFO)

// Запись с явным указанием уровня
logger.log("Важное сообщение", logging::LogLevel::WARNING);
```

#### Уровни логирования

```cpp
enum class LogLevel : int {
    DEBUG = 0,    // Отладочные сообщения
    INFO = 1,     // Информационные сообщения  
    WARNING = 2   // Предупреждения и ошибки
};
```

### Примеры использования

#### Файловое логирование

```cpp
#include "logging/Logger.h"

int main() {
    // Создание логгера с уровнем INFO по умолчанию
    logging::Logger logger("application.log", logging::LogLevel::INFO);
    
    if (!logger.isValid()) {
        std::cerr << "Ошибка создания логгера" << std::endl;
        return 1;
    }
    
    // Различные способы записи
    logger.info("Приложение запущено");
    logger.log("Пользователь вошел в систему");
    logger.warning("Низкий уровень свободной памяти");
    
    // Изменение уровня фильтрации
    logger.setDefaultLevel(logging::LogLevel::DEBUG);
    logger.debug("Теперь отладочные сообщения записываются");
    
    return 0;
}
```

#### Сокетное логирование

```cpp
#include "logging/Logger.h"

int main() {
    // Создание логгера для отправки в сокет
    logging::Logger logger("127.0.0.1", 12345, logging::LogLevel::INFO);
    
    if (!logger.isValid()) {
        std::cerr << "Ошибка подключения к серверу логов" << std::endl;
        return 1;
    }
    
    logger.info("Сообщение отправлено по сети");
    
    return 0;
}
```

#### Многопоточное использование

```cpp
#include "logging/Logger.h"
#include <thread>
#include <vector>

void workerFunction(logging::Logger& logger, int threadId) {
    for (int i = 0; i < 10; ++i) {
        logger.info("Поток " + std::to_string(threadId) + 
                   " сообщение " + std::to_string(i));
    }
}

int main() {
    logging::Logger logger("multithreaded.log", logging::LogLevel::INFO);
    
    std::vector<std::thread> threads;
    
    // Запуск нескольких потоков
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(workerFunction, std::ref(logger), i);
    }
    
    // Ожидание завершения
    for (auto& t : threads) {
        t.join();
    }
    
    return 0;
}
```

## Приложения

### test_logger - Тестовое приложение

Консольное многопоточное приложение для проверки библиотеки.

#### Использование

```bash
./test_logger <файл_журнала> [уровень_по_умолчанию]
```

#### Параметры

- `файл_журнала` - имя файла для записи журнала
- `уровень_по_умолчанию` - DEBUG, INFO или WARNING (по умолчанию: INFO)

#### Примеры

```bash
# Запуск с уровнем INFO
./test_logger app.log INFO

# Запуск с уровнем DEBUG  
./test_logger debug.log DEBUG
```

#### Формат ввода сообщений

```
# Использование уровня по умолчанию
Привет, мир!

# Указание уровня через двоеточие
WARNING: Это предупреждение

# Указание уровня через пробел
DEBUG Отладочное сообщение

# Выход из программы
quit
```

### log_stats - Приложение статистики

Консольная программа для сбора статистики по данным из сокета.

#### Использование

```bash
./log_stats <порт> <N> <T>
```

#### Параметры

- `порт` - порт для прослушивания подключений
- `N` - выводить статистику после каждого N-го сообщения
- `T` - таймаут в секундах для вывода статистики

#### Пример

```bash
# Слушать порт 12345, статистика каждые 10 сообщений или каждые 30 секунд
./log_stats 12345 10 30
```

#### Собираемая статистика

**Количество сообщений:**
- Общее количество
- По уровням важности (DEBUG, INFO, WARNING)
- За последний час

**Длины сообщений:**
- Минимальная длина
- Максимальная длина  
- Средняя длина

## Тестирование

### Юнит-тесты

Проект включает комплексные юнит-тесты, проверяющие:

- Базовую функциональность логирования
- Фильтрацию по уровням важности
- Изменение настроек во время выполнения
- Многопоточную безопасность
- Форматирование сообщений
- Обработку ошибок

### Запуск тестов

```bash
# Из директории сборки
make test

# Или с подробным выводом
ctest --verbose

# Или напрямую
./tests/test_logger
```

## Архитектура

### Компоненты библиотеки

#### LogOutput (абстрактный интерфейс)
- `FileOutput` - вывод в файл
- `SocketOutput` - вывод в сокет

#### Logger (основной класс)
- Управление уровнями логирования
- Потокобезопасная запись
- Форматирование сообщений

### Принципы проектирования

- **Инкапсуляция**: Скрытие деталей реализации
- **Полиморфизм**: Единый интерфейс для разных способов вывода
- **RAII**: Автоматическое управление ресурсами
- **Потокобезопасность**: Использование mutex для синхронизации
- **Исключения не используются** для бизнес-логики (согласно требованиям)

### Формат сообщений

```
[YYYY-MM-DD HH:MM:SS.mmm] [LEVEL] message
```

Пример:
```
[2024-01-15 14:30:25.123] [INFO] Приложение запущено
[2024-01-15 14:30:25.456] [WARNING] Низкий уровень памяти
```

## Ограничения и особенности

- Библиотека не использует сторонние зависимости (только STL)
- Исключения не используются для реализации бизнес-логики
- Целевая ОС: Ubuntu/Debian
- Стандарт: C++17
- Потокобезопасность обеспечивается на уровне класса Logger

## Развитие и расширения

### Возможные улучшения

- Поддержка ротации логов
- Конфигурационные файлы
- Асинхронное логирование
- Дополнительные форматы вывода (JSON, XML)
- Интеграция с системами мониторинга

### Добавление новых способов вывода

Для добавления нового способа вывода:

1. Наследовать от `LogOutput`
2. Реализовать методы `writeLog()` и `isValid()`
3. Добавить конструктор в класс `Logger`

```cpp
class DatabaseOutput : public LogOutput {
public:
    bool writeLog(const std::string& formattedMessage) override {
        // Реализация записи в базу данных
        return true;
    }
    
    bool isValid() const override {
        // Проверка соединения с БД
        return connected_;
    }
};
```

## Лицензия

Этот проект создан в учебных целях и не предназначен для коммерческого использования.
